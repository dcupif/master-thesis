Computer security is a decisive topic of the digital age. As we live in a time of unprecedented economic growth, increasingly fueled by computer and communications technology, software has become deeply entwined in our lives. From pocket-size devices, cell phones, desktop personal computers, servers, to the most complex and critical infrastructures (such as factories and nuclear power plants) we use software to automate, control, computerize, and manage our activities. All of those systems are now interconnected which creates incredible opportunities, but also tremendous threats. With the Internet era, the systems' exposure has increased drastically and the more complex the system, the more inevitable the security defects. In fact, computer security has moved beyond the realm of the technical elite and has a real impact on our everyday lives. Internet is an hostile environment and the need for secure systems has never been so critical.

\begin{flushright}
    \emph{``Without adequate security, we cannot realize the full potential of the digital age.''\\}
    \cite{chess2007secure} Brian Chess, Jacob West
\end{flushright}

Nonetheless, today's main approach for computer security is not really about solving security problems. It is more about answering those problems, responding and recovering from their consequenses. The software industry tends to put more effort into compensating for bad security instead of creating secure software in the first place. Even though network security can address and defend against some \glspl{vulnerability} (virus scanners, firewalls, and intrusion detection systems), those are only solutions in the short run.

Static Source Code Analysis (or simply Static Analysis) is one of the approaches that have become increasingly popular by the mid-2000s to avoid or remove defects before they could be triggered or exploited. It focuses on taking a program, either in source or binary form as input, and examining it to find security and quality defects in its code. The analysis is static, i.e., the program is not executed during the process. Static analysis power is in exploring states that would be hard to reach by running the code and enabling quick consideration of many possibilities.

Static analysis remains, however, a complex and a computationally undecidable problem. Most static analyzers overcome these obstacles by making trade-offs between precision and scalability, which sometimes leads to erroneous results. Following the need to evaluate the effectiveness of these tools, the \gls{samate} team at the \gls{nist} has already organized five \glspl{sate}. ``\gls{sate} is designed to advance research (based on large tests sets) in, and improvement of, static analysis tools that find security-relevant defects in source code. Briefly, participating tool makers run their tools on a set of programs. Researchers led by \gls{nist} analyze the tool reports. The results and experiences are reported at a workshop."

For its sixth edition, \gls{sate} needs improved test material. The \gls{samate} team realized indeed that the test cases used for the previous editions were not realistic enough. To elaborate and compute effective metrics, the test data should exhibit specific properties. My mission as a member of the \gls{samate} team was to contribute to the development of \gls{sate} VI test material, by manually seeding \glspl{vulnerability} into realistic production software.

In this master thesis, I will first describe the \acrfull{nist}. It has been a wonderful opportunity to work in such a challenging and inspiring environment. Second, I will introduce my project, explaining in-depth the background of my work. Then, I will draw a complete state of the art on two crucial themes closely related to what I am trying to achieve: static analysis and vulnerability addition. We will move onto the design of the solution in the following section. I will reflect on my work and think about the potential economic and technological impact on the software industry. I will state the current results of my project, and talk about the future implementations. Finally, I will end up describing the management of my project, and I will draw a conclusion on this experience.

\vfill

\emph{Attention: Should you encounter any unknown word in this paper, the numeric version provides the reader with direct links to the glossary by clicking on the words in the text.}